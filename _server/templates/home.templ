package templates

import (
	"time"
	"github.com/rubiojr/gasdb/_server/translations"
)

templ Home(lastUpdate *time.Time, t translations.Translations) {
	@Base(t.HomeTitle, t) {
		<div class="form">
			<div class="form-body">
				<h1 class="form-title mb-4">{ t.HomeHeading }</h1>
				if lastUpdate != nil {
					<p class="text-muted mb-3">
						<small>{ t.LastUpdated } { lastUpdate.Format("2006-01-02") }</small>
					</p>
				}
				<form action="/search" method="get" id="searchForm">
					<div class="mb-3">
						<label for="location" class="form-label">{ t.LocationLabel }</label>
						<input
							type="text"
							class="form-control"
							id="location"
							name="location"
							placeholder={ t.LocationPlaceholder }
						/>
					</div>
					<p class="form-text">{ t.LocationExample }</p>
					<!-- Hidden inputs for latitude and longitude -->
					<input type="hidden" id="latitude" name="lat"/>
					<input type="hidden" id="longitude" name="lng"/>
					<div class="btn-group mb-3">
						<button type="submit" class="btn btn-dark">{ t.SearchButton }</button>
						<button type="button" id="geolocateBtn" class="btn btn-outline-dark ms-2">{ t.UseLocationButton }</button>
					</div>
				</form>
				<div id="geoStatus" class="alert alert-info" style="display:none;"></div>
			</div>
		</div>
		<!-- Translation data for JavaScript -->
		<div id="translations" style="display:none;"
			data-geolocation-not-supported={ t.GeolocationNotSupported }
			data-requesting-location={ t.RequestingLocation }
			data-location-found={ t.LocationFound }
			data-permission-denied={ t.PermissionDenied }
			data-location-unavailable={ t.LocationUnavailable }
			data-location-timeout={ t.LocationTimeout }
			data-unknown-error={ t.UnknownError }>
		</div>
		<script>
			document.addEventListener('DOMContentLoaded', function() {
				const geolocateBtn = document.getElementById('geolocateBtn');
				const geoStatus = document.getElementById('geoStatus');
				const locationInput = document.getElementById('location');
				const latInput = document.getElementById('latitude');
				const lngInput = document.getElementById('longitude');
				const searchForm = document.getElementById('searchForm');
				const translations = document.getElementById('translations');

				// Check if geolocation is supported
				if (!navigator.geolocation) {
					geolocateBtn.disabled = true;
					geolocateBtn.textContent = translations.dataset.geolocationNotSupported;
					return;
				}

				geolocateBtn.addEventListener('click', function(e) {
					e.preventDefault();

					geoStatus.style.display = 'block';
					geoStatus.textContent = translations.dataset.requestingLocation;

					navigator.geolocation.getCurrentPosition(
						// Success callback
						function(position) {
							const lat = position.coords.latitude;
							const lng = position.coords.longitude;

							// Set the values in the hidden fields
							latInput.value = lat;
							lngInput.value = lng;

							// Clear the location input since we're using coordinates
							locationInput.value = '';

							geoStatus.textContent = translations.dataset.locationFound;

							// Submit the form
							searchForm.submit();
						},
						// Error callback
						function(error) {
							geoStatus.className = 'alert alert-error';

							switch(error.code) {
								case error.PERMISSION_DENIED:
									geoStatus.textContent = translations.dataset.permissionDenied;
									break;
								case error.POSITION_UNAVAILABLE:
									geoStatus.textContent = translations.dataset.locationUnavailable;
									break;
								case error.TIMEOUT:
									geoStatus.textContent = translations.dataset.locationTimeout;
									break;
								default:
									geoStatus.textContent = translations.dataset.unknownError;
									break;
							}
						},
						// Options
						{
							enableHighAccuracy: true,
							timeout: 5000,
							maximumAge: 0
						}
					);
				});
			});
		</script>
	}
}
